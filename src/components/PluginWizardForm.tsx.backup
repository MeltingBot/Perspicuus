/**
 * Wizard utilisant l'architecture de plugins - Version dÃ©couplÃ©e
 */

import React, { useState, useMemo } from 'react';
import {
  Box,
  Card,
  CardContent,
  Typography,
  Button,
  Alert,
  Stack,
  Stepper,
  Step,
  StepLabel,
  Paper,
  LinearProgress,
  Fade
} from '@mui/material';
import { 
  AssessmentOutlined,
  NavigateBefore,
  NavigateNext,
  CheckCircle 
} from '@mui/icons-material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import fr from 'date-fns/locale/fr';
import { frFR } from '@mui/x-date-pickers/locales';
import { 
  RiskAssessmentRequest, 
  ClientType, 
  PaymentMethod,
  RiskAssessmentResult 
} from '../types/lcbft';
import { LCBFTRiskEngine } from '../services/riskEngine';
import { pluginRegistry } from '../plugins';

// Import automatique des plugins
import '../plugins';

interface PluginWizardFormProps {
  onResults: (results: RiskAssessmentResult, formData: RiskAssessmentRequest) => void;
}

// Les Ã©tapes de base (non-plugin) restent identiques
const BASE_STEPS = [
  'Informations Client',
  'Localisation', 
  'Transaction',
  'VÃ©rifications'
];

export const PluginWizardForm: React.FC<PluginWizardFormProps> = ({ onResults }) => {
  const [activeStep, setActiveStep] = useState(0);
  const [formData, setFormData] = useState<RiskAssessmentRequest>({
    client: {
      type_client: ClientType.PERSONNE_PHYSIQUE,
      pep: false,
      sanctions: false,
      relation_etablie: 1,
      notoriete_defavorable: false,
      reticence_identification: false
    },
    geographic: {
      pays_residence: 'France',
      pays_compte: 'France', 
      distance_etablissement: 50
    },
    transaction: {
      montant: 10000,
      mode_paiement: PaymentMethod.VIREMENT,
      complexite_montage: false
    }
  });

  const [errors, setErrors] = useState<string[]>([]);
  const [pluginData, setPluginData] = useState<Record<string, any>>({});

  // GÃ©nÃ©ration dynamique des Ã©tapes avec plugins
  const steps = useMemo(() => {
    const activePlugins = pluginRegistry.getActivePlugins(formData.client);
    const pluginSteps = activePlugins.map(plugin => plugin.steps[0].stepName);
    
    return [...BASE_STEPS, ...pluginSteps];
  }, [formData.client]);

  const currentStepName = steps[activeStep];
  const isPluginStep = activeStep >= BASE_STEPS.length;

  // Gestionnaires de donnÃ©es des plugins
  const handlePluginDataChange = (pluginId: string, data: any) => {
    setPluginData(prev => ({
      ...prev,
      [pluginId]: data
    }));
  };

  const handleNext = () => {
    // Validation de l'Ã©tape actuelle
    if (isPluginStep) {
      const pluginStepIndex = activeStep - BASE_STEPS.length;
      const activePlugins = pluginRegistry.getActivePlugins(formData.client);
      const currentPlugin = activePlugins[pluginStepIndex];
      
      if (currentPlugin?.steps[0].validation) {
        const validationErrors = currentPlugin.steps[0].validation(pluginData[currentPlugin.config.id]);
        if (validationErrors && validationErrors.length > 0) {
          setErrors(validationErrors);
          return;
        }
      }
    }

    setErrors([]);
    if (activeStep < steps.length - 1) {
      setActiveStep(prev => prev + 1);
    }
  };

  const handleBack = () => {
    setErrors([]);
    setActiveStep(prev => prev - 1);
  };

  const handleFinish = () => {
    const finalErrors: string[] = [];
    
    // Validation de base
    if (!formData.transaction.montant || formData.transaction.montant <= 0) {
      finalErrors.push("Montant de transaction invalide");
    }
    if (formData.client.type_client === ClientType.PERSONNE_MORALE && !formData.client.code_naf) {
      finalErrors.push("Code NAF/APE obligatoire pour les personnes morales");
    }
    
    if (finalErrors.length > 0) {
      setErrors(finalErrors);
      return;
    }
    
    setErrors([]);
    
    try {
      // Calcul du risque de base
      const baseResults = LCBFTRiskEngine.evaluate(formData);
      
      // Calcul du risque agrÃ©gÃ© avec les plugins
      const aggregatedRisk = pluginRegistry.calculateAggregatedRisk(
        formData.client, 
        baseResults.score_total, 
        pluginData
      );
      
      // Mettre Ã  jour les rÃ©sultats avec le risque agrÃ©gÃ©
      const finalResults = {
        ...baseResults,
        score_total: aggregatedRisk,
        plugin_data: pluginData
      };
      
      onResults(finalResults, formData);
    } catch (error) {
      setErrors(['Erreur lors de l\'Ã©valuation du risque']);
    }
  };

  const renderPluginStep = () => {
    if (!isPluginStep) return null;
    
    const pluginStepIndex = activeStep - BASE_STEPS.length;
    const activePlugins = pluginRegistry.getActivePlugins(formData.client);
    const currentPlugin = activePlugins[pluginStepIndex];
    
    if (!currentPlugin) return null;
    
    const PluginComponent = currentPlugin.steps[0].component;
    
    return (
      <Fade in timeout={500}>
        <Stack spacing={4}>
          <Box display="flex" alignItems="center" mb={2}>
            {currentPlugin.config.icon}
            <Typography variant="h5" fontWeight="bold" sx={{ ml: 2 }}>
              {currentPlugin.config.name}
            </Typography>
          </Box>
          
          <Alert severity="info">
            <Typography variant="body2">
              <strong>Plugin:</strong> {currentPlugin.config.description}
            </Typography>
          </Alert>

          <PluginComponent
            clientInfo={formData.client}
            onDataChange={(data) => handlePluginDataChange(currentPlugin.config.id, data)}
          />
        </Stack>
      </Fade>
    );
  };

  const renderStepContent = (step: number) => {
    const stepName = steps[step];
    
    // Si c'est une Ã©tape de plugin
    if (step >= BASE_STEPS.length) {
      return renderPluginStep();
    }
    
    // Ici on garde le code des Ã©tapes de base inchangÃ©
    // Pour l'exemple, on retourne juste un placeholder
    return (
      <Fade in timeout={500}>
        <Stack spacing={4}>
          <Box display="flex" alignItems="center" mb={2}>
            <AssessmentOutlined sx={{ mr: 2, color: 'primary.main', fontSize: 32 }} />
            <Typography variant="h5" fontWeight="bold">
              {stepName}
            </Typography>
          </Box>
          
          <Alert severity="info">
            Ã‰tape de base: {stepName} (implementation Ã  conserver du wizard original)
          </Alert>
        </Stack>
      </Fade>
    );
  };

  return (
    <LocalizationProvider 
      dateAdapter={AdapterDateFns} 
      adapterLocale={fr}
      localeText={frFR.components.MuiLocalizationProvider.defaultProps.localeText}
    >
      <Card elevation={3} sx={{ maxWidth: 800, margin: 'auto' }}>
        <CardContent>
          <Box display="flex" alignItems="center" mb={4}>
            <AssessmentOutlined sx={{ mr: 2, color: 'primary.main', fontSize: 40 }} />
            <Box>
              <Typography variant="h4" component="h2" fontWeight="bold">
                Ã‰valuation LCBFT - Plugin Architecture
              </Typography>
              <Typography variant="subtitle1" color="textSecondary">
                Assistant d'Ã©valuation des risques avec plugins
              </Typography>
            </Box>
          </Box>

          <Box mb={4}>
            <Stepper activeStep={activeStep} alternativeLabel>
              {steps.map((label, index) => (
                <Step key={label}>
                  <StepLabel>
                    {index >= BASE_STEPS.length && 'ðŸ”Œ '}
                    {label}
                  </StepLabel>
                </Step>
              ))}
            </Stepper>
            <LinearProgress 
              variant="determinate" 
              value={(activeStep / (steps.length - 1)) * 100} 
              sx={{ mt: 2, height: 6, borderRadius: 3 }}
            />
          </Box>

          {errors.length > 0 && (
            <Alert severity="error" sx={{ mb: 3 }}>
              <ul style={{ margin: 0, paddingLeft: 20 }}>
                {errors.map((error, index) => (
                  <li key={index}>{error}</li>
                ))}
              </ul>
            </Alert>
          )}

          <Paper elevation={1} sx={{ p: 4, mb: 4, minHeight: 400 }}>
            {renderStepContent(activeStep)}
          </Paper>

          <Box display="flex" justifyContent="space-between">
            <Button
              disabled={activeStep === 0}
              onClick={handleBack}
              startIcon={<NavigateBefore />}
              variant="outlined"
              size="large"
            >
              PrÃ©cÃ©dent
            </Button>

            {activeStep === steps.length - 1 ? (
              <Button
                onClick={handleFinish}
                variant="contained"
                size="large"
                startIcon={<CheckCircle />}
              >
                Finaliser l'Ã©valuation
              </Button>
            ) : (
              <Button
                onClick={handleNext}
                variant="contained"
                size="large"
                endIcon={<NavigateNext />}
              >
                Suivant
              </Button>
            )}
          </Box>
        </CardContent>
      </Card>
    </LocalizationProvider>
  );
};